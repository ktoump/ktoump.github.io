<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>6.5 - ΜΙΑ ΟΛΟΚΛΗΡΩΜΕΝΗ ΣΤΡΑΤΗΓΙΚΗ ΑΔΙΕΞΟΔΟΥ</title>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_07.html">  Επόμενο κεφάλαιο</a>
	</nav>
    </head>
    <body>
        <header>
        </header>
        <article>
            <p>
            Υπάρχουν ισχυρά σημεία αλλά και αδυναμίες σε όλες τις στρατηγικές που σχετίζονται με αδιέξοδα. Θα ήταν πιο αποτελεσματικό να χρησιμοποιήσει κανείς διαφορετικές στρατηγικές σε διαφορετικές περιπτώσεις, παρά να προσπαθήσει να σχεδιάσει μια υπηρεσία του λειτουργικού συστήματος που θα εφαρμόζει μόνο μια από αυτές τις στρατηγικές.
            <h2>Μέθοδος 1:</h2>
            <ul>
                <li>Ομαδοποίησε τους πόρους σε έναν αριθμό διαφορετικών κλάσεων</li>
                <li>Χρησιμοποίησε τη στρατηγική της γραμμικής διάταξης, για την πρόληψη των αδιεξόδων μεταξύ των κλάσεων των πόρων</li>
                <li>Για μια κλάση πόρων, χρησιμοποιησε τον αλγοριθμο που ειναι ο πιο κατάλληλος για αυτή τη κλάση.</li>
            </ul>
            <h2>Μέθοδος 1 - κλάσεις πόρων:</h2>
            <ul>
                <li>Χώρος εναλλαγής: Τμήματα μνήμης δευτερεύουσας αποθήκευσης για χρήση σε διεργασίες εναλλαγής.</li>
                <li>Πόροι διεργασίας: Εκχωρήσιμες συσκευές όπως αρχεία.</li>
                <li>Κύρια μνήμη: Εκχωρείται με τη μορφή σελιδών (pages) ή τμημάτων (segments) στις διεργασίες.</li>
                <li>Εσωτερικές πηγές: Όπως κανάλια Ε/Ε</li>
            </ul>
            </p>
            <p>
            Η σειρά της παραπάνω καταγραφής αναπαριστά με την οποία ανατίθενται οι πόροι. Η σειρα ειναι λογική, ένα αναλογιστεί κανείς την ακολουθία των βημάτων μιας διεργασιας σε όλη τη διαρκεια της υπαρξης της. Σε καθε κλαση μπορουν να χρησιμοποιηθουν οι ακολουθες στρατηγικες:
            <ol>
                <li>Χώρος ανταλλαγής: Πρόληψη αδιεξόδων αξιωνοντας οτι ολοι οι απαιτουμενοι ποροι που μπορουν να χρησιμοποιηθουν, θα εκχωρουνται την ιδια στιγμή, οπως και στην περιπτωση της κατοχής και αναμονής στην στρατηγική προληψης. Η στρατηγική αυτή ειναι λογική στην περιπτωση που ειναι γνωστες οι μεγιστες απαιτήσεις σε αποθηκευτικο χωρο. Η αποφυγή αδιεξόδου ειναι επισης πιθανή.</li>
                <li>Πόροι διεργασίας: Η αποφυγή του αδιεξόδου σε αυτήν την κατηγορία είναι συχνα αποτελεσματική καθώς είναι λογικό οι διεργασίες να πρεπει εκ των προτέρων να δηλώσουν τους πόρους που θα χρειαστούν σε αυτή τη κλάση. Επίσης, πιθανή είναι και η πρόληψη μέσω της κατάταξης των πορων της κλάσης.</li>
                <li>Κύρια μνήμη: Η πρόληψη μέσω της προεκχωρησης φαινεται να ειναι ποιο αποτελεσματική στρατηγική για την περιπτωση της κυριας μνήμης. Όταν μια διεργασια εκχωρειται, εναλλασσεται στη δευτερευουσα μνήμη, ελευθερωνοντας χωρο για την επιλυση του αδιεξόδου.</li>
                <li>Εσωτερικες πηγες: Η πρόληψη μπορει να πραγματοποιηθει μεσω της καταταξης των πορων.</li>
            </ol>
            </p>
            <p>
            <h2>οι συνδαιτυμονες φιλοσοφοι: σεναριο<br>η φυση του προβλήματος</h2>
            <ul>
                <li>Το πρόβλημα των συνδαιτυμόνων φιλοσοφων αποτελει κλασική περιπτωση συγχρονισμου και αποφυγής αδιεξόδου. Προτάθηκε και επιλυθηκε απο τον Dijkstra το 1965</li>
                <li>Οι φιλόσοφοι σκεφτονται και με μη προκαθορισμενη σειρα και συχνότητα επιχειρουν να φανε</li>
                <li>Για το σκοπο αυτο χρειαζονται προσβαση σε δυο πιρουνια (το δεξι και το αριστερο τους)</li>
                <li>Δυο φιλοσοφοι δεν μπορουν να χρησιμοποιησουν ταυτόχρονα το ίδιο πιρουνι (αμοιβαιος αποκλεισμος)</li>
                <li>Ολοι οι φιλοσοφοι πρεπει να μπορουν να φανε καποια στιγμή (αποφυγή αδιεξοδου ή κυριολεκτικα παρατεταμενης στερησης)</li>
            </ul>
            </p>
            <p>
            <h2>μια πρωτη λυση με σηματοφορους</h2>
            <ul>
                <li>Ο κάθε φιλοσοφος πρωτα πιανει το αριστερο του πιρουνι και μετα το δεξί.</li>
                <li>Αφου τελειωσει να τρωει, αφηνει τα πιρουνια κατω.</li>
                <li>Η λυση μπορει να οδηγησει σε αδιεξοδο αν τυχει και οι πεντε φιλοσοφοι την ιδια στιγμη να πιασουν το αριστερο τους πιρουνι</li>
                <li>Τοτε θα δημιουργηθει μια κατασταση οπου κανενας δεν θα μπορει να πιασει το δεξι του πιρουνι και επομενως να ειναι σε θεση να φαει</li>
            </ul>
            </p>
            <p>
            <h2>αποφυγή του αδιεξοδου</h2>
            <li>Με την χρηση ενος γενικου σημαφορου με τιμη μια μικροτερη απο τον αριθμο των φιλοσοφων, τουλαχιστον ενας φιλοσοφος θα μπορεσει να εχει προσβαση και στα δυο του πιρουνια και επομενως να φαει.</li>
            <li>Η λυση αυτη δεν υποφερει απο αδιεξοδο και αν ο σημαφορος room ειναι ισχυρος δεν υποφερει και απο παρατεταμενη στερηση.</li>
            </p>
            <p>
            <h2>αναγκη για διαχειριση μνήμης</h2>
            <ul>
            <li>Η μνήμη είναι φθηνή στις μερες μας και γινεται φτηνοτερη.</li>
            <ul>
                <li>Ομως αυξανεται και η αναγκη των εφαρμογων σε περισσοτερη μνήμη.</li>
                <li>Οση μνήμη και να εχουμε δεν ειναι αρκετη!</li>
            </ul>
            <li>Σε ενα συστημα μονοπρογραμματισμού, μνήμη χωρίζεται σε αυτή που χρησιμοποιει το ΛΣ και σε αυτη που χρησιμοποιει το προγραμμα του χρήστη.</li>
            <li>Αν υποστηρίζεται πολυπρογραμματισμος, τοτε η μνήμη για τον χρήστη διαμοιραζεται αναμεσα στις εκτελουμενες διεργασιες</li>
            <li>Λογω της μεγαλης διαφορας ταχυτητας μεταξύ της ΚΜΕ και των συσκευων Ε/Ε, είναι σημαντικο να υπαρχει παντα στη μνήμη ενας ικανος αριθμος διεργασιων ετσι ωστε να μην υποχρησιμοποιειται η ΚΜΕ αν ολες οι διεργασιες που βρησκονται στη μνήμη ειναι σε αναστολη</li>
            <li>Κατ'επεκταση το ΛΣ πρεπει να εναλλασει με εξυπνο τροπο τις διεργασιες που βρισκονται στη μνήμη με άλλες που βρισκονται στο δίσκο, έτσι ώστε να υπαρχει παντα στη μνήμη ένας ικανοποιητικος αριθμος απο διεργασίες που ειναι σε κατασταση ετοιμες για εκτελεση.</li>
            </ul>
            </p>
            <p>
            <h2>Διαχειριση μνήμης</h2>
            <ul>
                <li>Το τμήμα του ΛΣ που διαχειριζεται τη μνήμη λεγεται Διαχειριστής Μνήμης (Memory Manager).</li>
                <li>Καθήκον του ειναι να παρακολουθει ποια τμήματα της μνήμης ειναι σε χρήση και ποια οχι, να χορηγει μνήμη σε διεργασιες οποτε τη χρειαζονται και να την επαναχορηγει σε αλλες οταν οι πρωτες ολοκληρωνουν την αποστολη τους, καθώς και να διαχειριζεται την εναλλαγή πληροφοριων (swapping) μεταξύ κυριας μνήμης και δισκου οταν η κυρια μνήμη δεν ειναι αρκετη για να εξυπηρετηθουν ολες οι διεργασιες.</li>
            </ul>
            </p>
            <p>
            <h2>Αναγκες για τη διαχειριση μνήμης</h2>
            Συγκεκριμένα, η διαχείρηση μνήμης απαιτει την ικανοποιηση των ακολουθων αναγκών:
            <ul>
                <li>Μετατόπιση (relocation)</li>
                <li>Προστασία (protection)</li>
                <li>Διαμοιραση (sharing)</li>
                <li>Λογικη οργανωση (logical organisation)</li>
                <li>Φυσικη οργανωση (physical organisation)</li>
            </ul>
            </p>
            <p>
            <h2>Μετατοπιση</h2>
            <ul>
                <li>Αν μια διεργασια χρειασθει να απομακρυνθει απο την κυρια μνήμη, δεν θα πρεπει να ειναι αναγκαιο οταν επανελθει να αποθηκευθει στον ιδιο χώρο που καταλαμβανε προηγουμενως.</li>
                <li>Για να ικανοποιηθει αυτη η αναγκη θα πρεπει οι διευθυνσεις μνήμης που χρησιμοποιουν οι εντολες του προγραμματος να μην ειναι απολυτες αλλα σχετικες ως προς το περιεχομενο καποιου καταχωρητή.</li>
                <li>Κατα την αποκωδικοποιηση τους, οι διευθυνσεις μνήμης μετατρεπονται απο σχετικες σε απολυτες (φυσικες)</li>
            </ul>
            </p>
            <p>
            <h2>Προστασια</h2>
            <ul>
                <li>Καμία διεργασια δεν πρεπει να μπορει να αναφερθει σε θεση μνήμης που ανηκει σε αλλη διεργασία (χωρις σχετική αδεια).</li>
                <li>Το προβλημα γινεται πιο δύσκολο λογω της μετατοπισης των διεργασίων στην κύρια μνήμη και ο ελεγχος πρεπει να γινεται δυναμικα και όχι στατικα (την ώρα της μεταφρασης).</li>
            </ul>
            </p>
            <p>
            <h2>Διαμοιραση</h2>
            <ul>
                <li>Περισσοτερες απο μια διεργασιες θα πρεπει να μπορουν να αναφερονται στον ιδιο χωρο μνήμης. Πχ. όλες οι διεργασίες ενός προγραμματος θα πρεπει να μπορουν να αναφερονται</li>
                <li>Έιναι επιθυμητο ολες οι διεργασιες να εχουν προσβαση στο ιδιο αντιγραφο του προγραμματος αντι η καθε μια να εχει προσβαση σε διαφορετικο αντιγραφο</li>
            </ul>
            </p>
            <p>
            <h2>Λογικη οργανωση</h2>
            <ul>
                <li>Αν και η μνήμη (κυρια και περιφερειακη) ειναι ουσιαστικα ενας μονοδιαστατος πινακας που αποτελειται απο μια σειρα απο bytes, εν τουτις σε λογικο επιπεδο θα πρεπει να υποστηριζει τη λογικη δομή ενος τυπικου προγραμματος:
                <ul>
                    <li>Χωρισμός σε ενότητες (modules), κοινη χρηση καποιων ενοτητων απο προγραμμα, κλπ.</li>
                </ul>
                </li>
                <li>
                Αυτή η προσεγγιση εχει ενα αριθμο απο πλεονεκτήματα όπως:
                <ul>
                    <li>Μερική αλλαγή και μεταφραση καποιων ενοτήτων.</li>
                    <li>Χρήση διαφορετικων μηχανισμων προστασιας σε καθε ενοτητα (πχ. μονο για διαβασμα ή εκτελεση).</li>
                </ul>
                </li>
            </ul>
            </p>
            <p>
            <h2>Φυσικη οργανωση</h2>
            <ul>
                <li>Δεν ειναι λογικο να επιφορτισουμε τον προγραμματιστή με την ευθύνη να διαχειριζεται τη μνήμη.</li>
                <li>Η διαθεσιμη μνήμη για καποιο προγραμμα μπορει να μην ειναι αρκετη για την εκτελεση του προγραμματος και οι τεχνικες επικαλυψης που πρεπει να χρησιμοποιηθουν σε τετοιες περιπτωσεις ειναι χρονοβορες</li>
                <li>Ο προγραμματιστης γενικως δεν ειναι σε θεση να γνωριζει ποση μνήμη ειναι διαθεσιμη</li>
                <li>Επομένως, η ευθύνη μεταφορας πληροφοριων μεταξυ κυριας και περιφερειακης μνήμης πρεπει να ανηκει στο ΛΣ</li>
            </ul>
            </p>
            <p>
            <h1>τμηματοποιηση</h1>
            Μια απο τις πρωτες τεχνικες διαχειρισης της μνήμης - Αν και δεν χρησιμοποιειται τοσο πολυ στις μερες μας (χωρις συνδυασμο με ιδεατη μνήμη), η μελετη της θα βοηθήσει στην κατανόηση πιο μοντερνων τεχνικών, όπως αυτών που βασιζονται σε ιδεατη μνήμη.
            </p>
            <p>
            <h1>ειδη τμηματοποιησης</h1>
            <ul>
                <li>Σταθερα τμήματα (fixed partitioning)</li>
                <li>Δυναμικά τμήματα (dynamic partitioning)</li>
                <li>Απλη σελιδοποιηση (simple paging)</li>
                <li>Σελιδοποιηση με χρηση ιδεατης μνήμης (virtual memory paging)</li>
                <li>Κατατμηση με χρήση ιδεατης μνήμης (virtual memory segmentation)</li>
            </ul>
            </p>
            <p>
            <h2>σταθερα τμήματα</h2>
            <ul>
                <li>Με εξαιρεση το χωρο της μνήμης που χρειαζεται το ΛΣ, ο υπολοιπος χωριζεται σε σταθερα ισομεγεθη τμήματα.</li>
                <li>Οποιαδήποτε διεργασία της οποιας το μεγεθος ειναι μικροτερο ή ίσο με αυτο των τμηματων, μπορει να φορτωθει σε οποιαδήποτε ελευθερο τμήμα</li>
                <li>Το ΛΣ μπορει να απομακρυνει μια διεργασια απο καποιο τμήμα αν αυτη δεν εκτελειται ή δεν ειναι σε κατάσταση έτοιμη για εκτελεση.</li>
            </ul>
            </p>
            <p>
            <h2>προβλήματα με την τεχνίκη των ισομεγεθων σταθερων τμηματων</h2>
            <ul>
                <li>Στην περιπτωση που καποιο προγραμμα ειναι μεγαλυτερο απο το μεγεθος των τμηματων θα πρεπει να χωρισθει σε τμήματα επικαλυψης (overlays) και να μεταφερεται στο χωρο της κυριας μνήμης που ανηκει στο τμήμα εκεινο του προγραμματος που πρεπει να εκτελεσθει, επικαλυπτοντας το προηγουμενο τμημα του προγραμματος.</li>
                <li>Εδω γινεται προσπαθεια να χωρισθει ενα προγραμμα σε μερη ανεξαρτητα (κατα το δυνατον) μεταξυ τους: πχ ενα τμήμα για εισοδο δεδομενων, ενα για την επεξεργασια τους και ενα ακομα για την εξοδο των αποτελεσματων</li>
                <li>Η εργασια αυτη πρεπει να γινει απο τον προγραμματιστή και ειναι βασανιστική, βαρετη και χρονοβόρα.</li>
                <li>Επισης, η μεθοδος αυτη οδηγει σε σπαταλη μνήμης στη (οχι σπανια) περιπτωση που καποιο προγραμμα ειναι μικροτερο απο το μεγεθος των τμηματων.</li>
                <li>Αυτο το φαινομενο ονομαζεται εσωτερικος κατακερματισμος (internal fragmentation)</li>
            </ul>
            </p>
            <p>
            <h2>Λυση: ανισομεγεθη σταθερα τμήματα</h2>
            <ul>
                <li>Ελαττωνει το προβλημα αλλα δεν το εξαλειφει τελειως.</li>
                <li>Στο διπλανο σχήμα, προγραμματα μέχρι 16 MB μπορουν να αποθηκευθουν χωρις χρήση επικαλυψης και τα μικροτερα προγραμματα μπορουν να αποθηκευθουν σε μικροτερα τμήματα, μειώνοντας ετσι τον εσωτερικο κατακερματισμό.</li>
            </ul>
            </p>
            <p>
            <h2>Αλγοριθμοι τοποθετησης για τα σταθερα ισομεγεθη τμήματα</h2>
            <ul>
                <li>Ο αλγόριθμος τοποθετησης (placement algorithm) για σταθερα ισομεγεθη τμήματα ειναι πολυ απλος: Το προγραμμα τοποθετειται σε οποιαδηποτε ελευθερο τμήμα.</li>
            </ul>
            </p>
            <p>
            <h2>Αλγόριθμοι τοποθετησης για τα σταθερα ανισομεγέθη τμήματα</h2>
            <ul>
                <li>Σε αυτήν την περιπτωση τιθεται το ερωτημα με ποιο τροπο διαμοιραζουμε τα διαθεσιμα τμήματα στα προγραμματα. Υπαρχουν δυο εναλλακτικες λυσεις:</li>
                <li>Κάνοντας χρηση πολλαπλων ουρών αναθετουμε στο καθε προγραμμα το μικροτερο σε μεγεθος τμήμα που ικανοποιει τις αναγκες του.</li>
                <li>Αυτο προυποθετει ομως οτι καποιο προγραμμα γνωριζει εκ των προτερων τις αναγκες του σε μνήμη.</li>
                <li>Επισης, μπορει να ελαχιστοποιειται η σπαταλη μνήμης μέσα σε ένα τμήμα αλλα συνολικα υπαρχει ακομα σπαταλη γιατι μπορει καποιο τμήμα να παραμενει αχρησιμοποιητο αν δεν υπαρχει καποιο προγραμμα αρκετα μεγάλο για να δικαιολογειται η αναθεση του σε αυτο.</li>
                <li>Εναλλακτικά, κάνοντας χρήση μίας ουρας, αναθέτουμε σε κάποιο προγραμμα το μικροτερο διαθέσιμο τμήμα.
                <br>Αν δεν υπαρχει διαθεσιμο τμήμα, καποιο απο τα προγραμματα που βρίσκονται στην κύρια μνήμη θα πρεπει να μεταφερθει στο δίσκο (κατα προτίμηση καποιο που βρίσκεται σε τμήμα του μεγέθους που χρειαζεται το νεο προγραμμα για να τρεξει, αλλα μπορει να ληφθουν υπ'οψη εδω και αλλα κριτηρια οπως προτεραιοτητες, κατασταση διεργασιων, κλπ)</li>

            </ul>
            </p>
            <p>
            <h2>Παραμενοντα προβλήματα με την τεχνική των σταθερων τμημάτων</h2>
            <ul>
                <li>Ο αριθμος των εν ενεργεια διεργασιων στο συστημα περιοριζεται στον αριθμο των τμημάτων.</li>
                <li>Επειδη γενικως οι αναγκες σε μνήμη μιας τυπικης εργασιας δεν μπορουν να προκαθορισθουν, ο χωρισμος της μνήμης σε τμήματα διαφορετικου μεγέθους δεν μπορει να γινει αποτελεσματικα και σπαταλειται σημαντική ποσοτητα μνήμης.</li>
                <li>Η υπαρξη πολλως διεργασιων περιορισμενης αναγκης σε μνήμη, επισης θα οδηγησει σε σπαταλη μνήμης.</li>
                <li>Ενα απο τα πιο επιτυχημενα ΛΣ που χρησιμοποιουσαν αυτη τη μεθοδο ειναι το OS/MFT (Multiprogramming with a Fixed number of Tasks) της IBM.</li>
            </ul>
            </p>
            <p>
            <h2>Δυναμικα τμηματα</h2>
            <ul>
                <li>Μερικα απο τα προβληματα της χρήσης σταθερων τμηματων επιλυονται με τη χρηση μεταβλητων τμηματων.</li>
                <li>Σε καθε διεργασια εκχωρειται η ποσοτητα της μνήμης που χρειαζεται, εφ'οσον βεβαιως ειναι διαθεσιμη.</li>
                <li>Καποια στιγμή, καποια απο τις διεργασιες που βρισκονται στην κύρια μνήμη θα αποδεσμευσει τη μνήμη που χρησιμοποιουσε (είτε γιατι τερματισε ειτε γιατι θα μεταφερθει στο δίσκο).</li>
                <li>Τον χωρο που απελευθερωνεται μπορει να καταλαβει μια <i>ή περισσότερες</i> διεργασιες αναλογα με τις αναγκες τους.</li>
                <li>Αντιθετα με την περιπτωση των σταθερων τμηματων, εδω ο αριθμος, η θεση και το μεγεθος των τμηματων καθώς επισης και ο αριθμος των διεργασιων στην κυρια μνήμη ειναι μεταβλητος</li>
            </ul>
            </p>
            <p>
            <h2>Δυναμικα τμήματα: Πλεονεκτήματα</h2>
            Δεν εγκλωβιζόμαστε σε σταθερο αριθμό τμημάτων και αυξανεται έτσι η αποδοση της μνήμης μεσω της αυξησης του βαθμού πολυπρογραμματισμού του συστήματος
            </p>
            <p>
            <h2>Δυναμικα τμηματα: Μειονεκτηματα</h2>
            <ul>
                <li>Απο την άλλη πλευρα όμως ο μηχανισμος δεσμευσης και αποδεσμευσης της μνήμης και ο μηχανισμος παρακολουθησης των μεταβολων που λαμβανουν χωρα γινεται πιο πολυπλοκος.</li>
                <li>Ένα αλλο προβλημα που δημιουργειται ειναι οτι καποια στιγμή θα υπαρχουν στη μνήμη πολλα μικρα κενα τμήματα τα οποια αν και συνδυασμενα θα μπορουσαν να ικανοποιησουν τις αναγκες καποιας διεργασιας, απο μονα τους αχρηστα.
                <br>Αυτο το φαινομενο ονομαζεται εξωτερικος κατακερματισμος (external fragmentation)</li>
                <li>Ο Knuth υπολόγισε ότι σε γενικες γραμμες τα κενα h θα ειναι κατα μεσο ορο τα μισα απο ότι οι διεργασίες n (δηλαδη h=n/2). Το αποτελεσμα αυτο ειναι γνωστο <i>σαν κανονας του 50%</i> (fifty percent) και βασιζεται στην παρατηρηση οτι εφαπτομενα κενα συνενωνονται σε ενα</li>
                <li>Μια πιθανή λυση θα ήταν η περιοδική μετακίνηση από το ΛΣ ολων των τμηματων ετσι ωστε να βρισκονται σε συνεχομενες θεσεις και επομενως οι ελευθεροι χωροι να ειναι και αυτοι μαζι σαν ενα τμήμα.</br>
                Αυτή η μέθοδος ονομάζεται συμπίεση μνήμης (compaction) αλλα χρησιμοποιειται σπανια γιατι ειναι πολυ δαπανηρη σε χρονο ΚΜΕ. πχ: σε μια μηχανή με 1 ΜΒ μνήμη και με δυνατοτητα μεταφορας 1 byte/msec (δηλαδη 1MB/sec) θα χρειαζοταν ενα δευτερολεπτο για τη συμπιεση ολης της μνήμης.</li>
            </ul>
            </p>
            <p>
            <h2>αλγοριθμοι τοποθετησης για τα δυναμικα τμήματα</h2>
            <ul>
                <li>Για την επιλογη του καταλληλου τμήματος μνήμης για τις αναγκες μιας διεργασιας χρησιμοποιειται ενας απο τους ακολουθους αλγοριθμους τοποθετησης.</li>
                <li>Ο κοινος παρανομαστής για όλους είναι η προσπαθεια ευρεσης ενος τμήματος μνήμης ισου ή μεγαλυτερου αυτου που καποια διεργασια εχει αναγκη με τροπο που να ελαχιστοποιει τη σπαταλη μνήμης αλλα και τη συχνοτητα χρήσης τεχνικων συμπιεσης</li>
            </ul>
            </p>
            <p>
             <h2>πρωτη τοποθετηση</h2>
             <ul>
                 <li>Ο αλγοριθμος της πρωτης τοποθετησης (first-fit) σαρωνει τη μνήμη και διαλεγει το πρωτο τμήμα που θα βρει και ειναι κατάλληλο για τις αναγκες του προγραμματος</li>
                 <li>Αν το τμήμα αυτο ειναι μεγαλυτερο απο οσο χρειαζεται το διασπα σε δυο κομματια.</li>
                 <li>Ειναι ο απλουστερος απο τους αλγοριθμους, γρηγορος στην εκτελεση και παραδοξως εχει συνηθως καλα αποτελεσματα.</li>
             </ul>
             <h2>Επομενη τοποθετηση</h2>
             <ul>
                 <li>Μια παραλλαγή του προηγουμενου αλγοριθμου ειναι αυτος της επομενης τοποθετησης (next-fit) οπου η αναζήτηση ενός καταλληλου τμήματος ξεκιναει απο το σημειο που βρεθηκε το τελευταιο κατάλληλο τμήμα αντι απο την αρχη της μνήμης.</li>
                 <li>Μελετες προσομοιωσης απο τον Bays εδειξαν οτι ο αλγοριθμος αυτος εχει ελαφρως χειροτερα αποτελεσματα απο αυτον της πρωτης τοποθετησης.</li>
                 <li>Τεινει να χορηγει μνήμη απο το μεγαλυτερο διαθεσιμο κομματι που βρισκεται προς το τελος της μνήμης (υψηλοτερες διευθυνσεις).</li>
                 <li>Επομενως η περιοχη εκεινη της μνήμης σπαει γρηγορα σε μικρα και αχρηστα τμήματα, δημιουργωντας την αναγκη χρήσης τεχνικων συμπιεσης.</li>
                 <li>Παρεπιπτοντως, το αντιθετο συμβαινει με τον προηγουμενο αλγοριθμο ο οποιος δημιουργει το ιδιο προβλημα στις χαμηλες θεσεις μνήμης.</li>
             </ul>
             <h2>Καλυτερη τοποθετηση</h2>
             <ul>
                 <li>Ο αλγοριθμος της καλυτερης τοποθετησης (best-fit) προσπαθει να βρει το τμήμα εκεινο της μνήμης που ειναι οσο γινεται πιο μικρο (αλλα βεβαιως να εξακολουθει να ικανοποιει τις αναγκες του προγραμματος).</li>
                 <li>Αν και φαινεται λογικη αυτη η προσεγγιση, γιατι προσπαθει να ελαχιστοποιήσει τα αχρησατ κενα, εν τουτοις δημιουργει μεγαλυτερο προβλημα γιατί τα κενά που αναπόφευκτα θα δημιουργηθούν είναι πολύ μικρά και άχρηστα ακόμα και για μικρά προγράμματα.</li>
                 <li>Επισης είναι πιο αργός απο τους προηγουμενους λόγω της σάρωσης όλης της μνήμης.</li>
             </ul>
             <h2>Χειρότερη τοποθέτηση</h2>
             <ul>
                 <li>Ο αλγόριθμος της χειρότερης τοποθέτησης (worst-fit) κανει ακριβώς το αντίθετο ψάχνοντας να βρει το μεγαλύτερο τμήμα έτσι ώστε όταν διασπασθεί το υπόλοιπο κομμάτι να είναι αρκετά μεγάλο για να παραμείνει χρήσιμο.</li>
                 <li>Προγραμμα προσομοιωσης εδειξε οτι δεν ειναι πολυ αποτελεσματικος.</li>
             </ul>
            </p>
            <p>
            <h2>Μετατόπιση</h2>
            <ul>
                <li>Για τους περισσοτερους απο τους μηχανισμους που εξετασαμε μεχρι τώρα ισχυει οτι το τμήμα μνήμης που θα καταλαβει μια διεργασια στην κύρια μνήμη δεν είναι κατ'ανάγκη το ίδιο με αυτό που καταλάμβανε την προηγουμενη φορα που είχε εισέλθει στην κύρια μνήμη.</li>
                <li>Επίσης, κατα τη συμπιεση της μνήμης, μία διεργασία τυχον να μετακινηθεί σε άλλο χωρο.</li> <!-- XXX what??? -->
                <li>Θα πρέπει λοιπόν οι διευθυνσεις μνήμης που χρησιμοποιούν οι εντολες του προγράμματος να αλλάζουν ανάλογα.</li>
                <li>Αυτο οδηγεί στην αναγκη υποστηριξης μηχανισμών μετατόπισης (relocation).</li>
            </ul>
            </p>
            <p>
            <h2>ειδη διευθυνσεων</h2>
            <ul>
                <li><b>Λογική:</b> Αναφορα σε μια θεση μνήμης ανεξαρτητα απο το που στη μνήμη βρίσκονται τα δεδομένα.</li>
                <li><b>Σχετική: </b> Αναφορα σε μια θεση μνήμης με βάση ένα γνωστο σημειο αναφορας</li>
                <li><b>Φυσικοι ή απολυτη: </b>Αναφορά στην απόλυτη θεση μνήμης στο φυσικο υλικο χωρο μνήμης του συστήματος</li>
            </ul>
            </p>
            <p>
            <h2>ειδη διευθυνσεων</h2>
            <ul>
                <li>
                Η τεχνική που συνηθως ακολουθειται (και η οποια ικανοποιει και τις αναγκες της προστασιας) ειναι να υπαρχουν δυο ειδικοι καταχωρητων:
                <ul>
                    <li>ο καταχωρητης βάσης (base register), και</li>
                    <li>ο καταχωρητης οριου (limit, bounds register).</li>
                </ul>
                </li>
                <li>Ο πρωτος έχει ως τιμή τη διευθυνση της αρχης του τμηματος ενω ο δευτερος το μεγεθος (ή το τέλος) του τμήματος.</li>
                <li>Σε καθε διευθυνση των εντολων της διεργασιας προστιθεται αυτοματα η τιμη του καταχωρητη βασης και η καινουγια διευθυνση ελεγχεται με βαση την τιμη του καταχωρητή οριου για να διαπιστωθει αν ανηκει στα επιτρεπτα ορια μνημης που ελεγχει η διεργασια</li>
            </ul>
            </p>
        </article>
	<footer>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_07.html">  Επόμενο κεφάλαιο</a>
	</nav>
	</footer>
    </body>
</html>

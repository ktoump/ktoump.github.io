<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Κεφαλαιο 5 - Ταυτοχρονισμός</title>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_06.html">  Επόμενο κεφάλαιο</a>
	</nav>
	<link rel="stylesheet" type="text/css" href="style.css"/>
    </head>
    <body>
        <header>
        </header>
        <article>
        <h2>Λόγοι ανάγκης για ταυτόχρονη εκτέλεση διεργασιών</h2>
        <ul>
            <li> Πολυπρογραμματισμός (multiprogramming): Η διαχειριση πολλαπλών διεργασιών σε ένα συστημα με έναν επεξεργαστή.</li>
            <li> Πολυεπεξεργασία (multiprocessing): Η διαχείριση πολλαπλών διεργασιών σε ένα συστημα με πολλους επεξεργαστες.</li>
            <li> Κατανεμημένη επεξεργασια (distributed processing): Η διαχείρηση πολλαπλών διεργασιών σε ένα σύστημα με πολλαπλούς Η/Υ, συνδεδεμένους μεταξύ τους με κάποιο δίκτυο.</li>
        </ul>
        <h2>θεματα σχετιζόμενα με τον ταυτοχρονισμο</h2>
        <ul>
            <li> Επικοινωνία μεταξύ των διεργασιών.</li>
           <li> Διαμοιρασμός και ανταγωνιστικότητα στη χρήση των πόρων του συστήματος (όπως μνήμη, αρχεία, συσκευές)..</li>
           <li> Συχρονισμός μεταξύ των διεργασιών..</li>
           <li> Κατανομή του χρόνου της (ή των) ΚΜΕ στις διεργασίες..</li>
        </ul>
        <h2>Πηγές ταυτοχρονίας</h2>
        <ul>
            <li>Ταυτόχρονη εκτέλεση πολλαπλών εφαρμογών με διαμοιρασμό του χρόνου της ΚΜΕ μεταξύ τους.</li>
            <li>Ο δομημένος προγραμματισμός επιτρέπει το σχεδιασμό ενός προγράμματος ως μία ομάδα από ταυτόχρονα εκτελούμενες διεργασίες.</li>
            <li>Το ίδιο το ΛΣ αποτελείται από μια μεγάλη ομάδα από ταυτόχρονα εκτελούμενες διεργασίες ή/και νήματα.</li>
        </ul>
        <h2>Συντρέχων προγραμματισμός</h2>
        <ul>
        <li>Δημιουργείται η ανάγκη παροχής στον προγραμματιστή μηχανισμών για την υποστήριξη τεχνικών προγραμματισμού βασισμένων στην έννοια του ταυτοχρονισμού, όπως δημιουργία νέων διεργασιών, συντονισμός της ταυτόχρονης εκτέλεσης ενός αριθμού διεργασιών, διαδιεργασιακή επικοινωνία, δηλαδή επικοινωνία μεταξύ ταυτόχρονα εκτελούμενων διεργασιών, κλπ.</li>
        <li>Η μορφή αυτή προγραμματισμού αναφέρεται ως συντρέχων ή σύνδρομος (concurrent) Προγραμματισμός.</li>
        </ul>
        <h2>συρρουτινες</h2>
        <ul>
            <li>Ιστορικά, ο προπομπος του συντρέχοντος προγραμματισμού είναι ο μηχανισμός των συρρουτινών (coroutines) που προτάθηκε απο τον Conway το 1963. Ο προγραμματισμός με συρρουτίνες ήταν προέκταση του προγραμματισμού με διαδικασίες (procedures): ενώ στην περίπτωση των διαδικασιών μία διαδικασία έπρεπε να αποπερατώσει την εκτέλεση της πριν ο έλεγχος εκτέλεσης του προγράμματος επιστρέψει στη διαδικασία που την κάλεσε, στην περίπτωση των συρρουτινών ο έλεγχος εκτέλεσης του προγράμματος μπορούσε να μεταφερθεί από τη μία συρρουτίνα στην άλλη οποιαδήποτε στιγμή· επιπλέον, η καλούμενη συρρουτίνα επανάρχιζε την εκτέλεση της από το σημείο που είχε σταματήσει.</li>
            <li>Η διαφορά της έννοιας των συρρουτινών από αυτή του συντρέχοντος προγραμματισμού είναι ότι μόνο μια συρρουτίνα είναι ανά πάσα χρονική στιγμή ενεργοοποιημένη και ότι η εναλλαγή ενεργοποίησης των συρρουτινών γινεται στατικά σε συγκεκριμένα σημεία ενός προγραμματος.</li>
        </ul>
        <h2>προβλημα συντονισμου αριθμου διαδικασιων</h2>
        <ul>
            <li>Να διαβαστουν καρτες των 80 χαρακτήρων και να τυπωθούν σε γραμμες των 125 χαρακτήρων, μετά δε το τέλος κάθε κάρτας να εισαχθεί ενας κενος χαρακτήρας και κάθε δυο ** να αντικατασταθούν με ένα #.</li>
            <li>Σειριακή λύση με 3 διαδικασίες:
                <ul>
                    <li>Διαδικασία 1η: Διαβασε ολες τις καρτες σε προσωρινή μνήμη (buffer).</li>
                    <li>Διαδικασία 2η: Κανε τις αντικαταστασεις.</li>
                    <li>Διαδικασια 3η: Τυπωσε το αποτέλεσμα σε γραμμές των 125 χαρακτήρων.</li>
                </ul>
            </li>
            <li>Μειονεκτήματα: Χασιμο χρόνου (overhead) λόγω του ότι εκτελούνται πολλές εντολές Ε/Ε αλλά και μεγάλη σπατάλη μνήμης</li>
        </ul>
        <h2>Προβλήματα που δημιουργεί ο ταυτοχρονισμος (και αναλογες ευθυνες για το λσ)</h2>
        <ul>
            <li>Διαχείρηση των εκτελούμενων διεργασίων.</li>
            <li>Βελτιστη κατανομή των διαθέσιμων πορων αναφορικα με ΚΜΕ, κυρια και περιφερειακή μνήμη και συσκευές Ε/Ε μεταξύ των εκτελούμενων διεργασιών.</li>
            <li>Προστασία του περιβάλλοντος μιας διεργασιας απο μη επιτρεπτες παρεμβολές από τις αλλες διεργασίες.</li>
            <li>Ανεξαρτησία των αποτελεσματων που παράγει μια διεργασία απο την ταχύτητα εκτελεσης της σε σχεση με τις αλλες διεργασίες του συστήματος.</li>
            <li>Δυσκολια αποσφαλματωσης (debugging) των προγραμματων γιατι συνήθως η εκτελεση των διεργασιων και η εν γενει συμπεριφορά του συστήματος είναι μη προκαθορισμένη.</li>
        </ul>
        <h2>αλληλεπιδραση μεταξυ διεργασιων</h2>
        <p>Η ταυτόχρονη εκτέλεση περισσότερων της μίας διεργασιων οδηγεί συχνά σε φαινόμενα <i>αλληλεπίδρασης</i> μεταξύ των διεργασίων αυτών (process interaction) που μπορουν να χωρισθουν σε 3 κατηγορίες ανάλογα με το βαθμό στον οποιο μια διεργασια γνωρίζει την υπαρξη άλλων διεργασίων και πως τυχόν εκμεταλλεύεται αυτή τη πληροφορία:
        <ul>
            Οι διεργασίες δεν γνωριζουν η μια την ύπαρξη της άλλης (πχ οι διεργασίες που αντιστοιχούν στο κέλυφος ενός χρήστη στο Unix). Σε αυτή την περιπτωση δεν τιθεται θεμα υποστήριξης διαδιεργασιακής επικοινωνίας αλλά μπορει να δημιουργηθει προβλημα <i>ανταγωνισμού</i>, δηλαδή προσπάθεια από τις εκτελούμενες διεργασίες να δεσμευσουν τους ιδιους πορους.
            Οι διεργασιες γνωριζουν εμμεσα η μια την υπαρξη της αλλης (πχ μέσω της κοινής χρήσης ενός διαμοιραζόμενου αντικειμείνου οπως πχ προσωρινή μνήμη (buffer)). Σε αυτή την περιπτωση δημιουργείται το φαινόμενο της συνεργασίας (cooperation) μεσω προσπελασης στο κοινής χρήσης αντικείμενο.
            Οι διεργασίες γνωρίζουν άμεσα η μιά την υπαρξη της άλλης (πχ. στη χρήση διοχετευσεων στο Unix). Σε αυτή την περιπτωση οι διεργασίες γνωρίζουν η μιά την άλλη κατ'ονομα και έχουν σχεδιαστεί για να εργαζονται μαζί για την επιτευξη ενος στοχου. Επομένως και έδω έχουμε το φαινόμενο της συνεργασίας.
        </ul>
        </p>
        <p>
        <h2>Αμοιβαίος αποκλεισμός</h2>
        Για την αποφυγή συνθηκών ανταγωνισμού επιβάλλεται ο αμοιβαίος αποκλεισμός (mutual exclusion), δηλαδή ο αποκλεισμός μιας διεργασίας απο καποια ενέργεια που ταυτόχρονα επιτελει καποια άλλη διεργασία. Αυτό οδηγεί τον καθορισμο καποιων μερών στον κώδικα μιας διεργασιας στις οποιες η διεργασια αυτη προσπαθει να προσπελασει κοινά μεταξύ των διεργασιων αντικείμενα πχ διαμοιραζομενες περιοχες μνήμης, αρχεια, κλπ. Αυτα τα μέρη λέγονται κρισιμα τμήματα/περιοχές (critical sections/regions) και για τη σωστή εκτελεση συντρεχουσων διεργασιων πρεπει να διασφαλιστει οτι <i>ποτε δυο ή περισσοτερες διεργασίες δεν θα βρισκονται ταυτοχρονα στο ιδιο κρισιμο τμήμα.</i>
        </p>
        <p>
        <h2>προβλήματα σχετιζόμενα με τον αμοιβαίο αποκλεισμό</h2>
        <ul>
            <li>Αδιέξοδο (deadlock), όταν πχ. δύο διεργασιες χρειαζονται δυο πορους και κάθε μια απο τις διεργασίες έχει δεσμεύσει ένα από τους πόρους και έχοντας αρχίσει οι διεργασίες να εκτελούν το κρίσιμο τμήμα του κωδικά τους για τον δεύτερο πόρο ανακαλύπτουν ότι είναι δεσμευμένος από την άλλη διεργασία.</li>
            <li>Παρατεταμένη στέρησης (starvation), όπου κάποια διεργασία δεν προλαβαίνει να δεσμεύσει κάποιον πόρο λόγω της πιο γρήγορης δέσμευσής του από αλλες διεργασίες.</li>
        </ul>
        </p>
        <p>
        <h2>Άμεση συνεργασία μεταξύ διεργασιων</h2>
        Μέσω κοινής χρήσης καποιων αντικειμένων (μεταβλητών, αρχείων, βάσεων δεδομένων, κλπ) τα προβλήματα του αμοιβαίου αποκλεισμού, του αδιεξοδου και της παρατεταμένης στέρησης υπάρχουν και εδώ. Ομως τα κοινά αντικείμενα μπορούν να προσπελασθούν για δίαβασμα ή για γράψιμο και μονο στη δευτερη περιπτωση χρειαζεται αμοιβαίος αποκλεισμός. Ενα αλλο προβλημα που παρατηρειται εδω και έχει να κάνει με την ενημέρωση κοινών δεδομένων είναι αυτο της συνέπειας των δεδομένων (data coherence) οπως φαινεται στο ακολουθο παραδειγμα:
        <pre>
            P0: a = a+1; a = a+1;    (P0)
            b = b+1; b = 2*b;        (P1)
            P1: b = 2*b; b = b+1;    (P0)
            a = 2*a; a = 2*a;        (P1)
        </pre>
        όπου το ζητούμενο είναι μετά το τέλος εκτέλεσης των εντολών να ισχύει η σχέση a = b. Με την εκτέλεση στα αριστερά αυτό επιτυγχάνεται αλλά με την εκτέλεση στα δεξια δεν επιτυγχάνεται παρόλο που οι δυο διεργασίες έχουν σεβαστεί τη συνθήκη αμοιβαίου αποκλείσμου για τις δύο μεταβλητές ξεχωριστά. Αυτο που χρειαζεται είναι και οι τέσσερεις εντολές να θεωρηθούν κρισιμες.
        </p>
        <p>
        <h2>Έμμεση συνεργασία μεταξύ διεργασιών</h2>
        Μέσω άμεσης επικοινωνίας με τη χρήση μηνυμάτων (messages). Λόγω της έλλειψης κοινού αντικειμένου επικοινωνίας δεν τίθεται θέμα αμοιβαίου αποκλεισμού αλλά τα άλλα προβλήματα παραμένουν. Αδιέξοδος μπορεί να δημιουργηθεί αν μία διεργασία περιμένει μήνυμα από μία άλλη και αντίστροφα. Παρατεταμένη στέρηση μπορεί να προκύψει αν πχ μία διεργασία P0 προσπαθεί να επικοινωνήσει με 2 άλλες διεργασίες P1 και P2 και αυτές με την P0· η P0 μπορεί να επικοινωνεί συνεχώς με την P1 και η P2 να μην καταφέρει ποτέ να ανταλλάξει μηνύματα με την P0.
        </p>
        <p>
        <h2>Συμβολισμοι για ταυτοχρονη επεξεργασια</h2>
        <ul>
            <li>Για την υποστήριξη ταυτοχρονης επεξεργασίας στο επίπεδο λογισμικού θα πρέπει οι γλώσσες προγραμματισμούν να έχουν συμβολισμούς που να δηλώνουν ταυτοχρονία, διαδιεργασιακή επικοινωνία, κρισιμα τμήματα, κλπ. Κάθε γλωσσα προγραμματισμού έχει τους δικούς της συμβολισμούς αλλά για μια γλώσσα βασισμένη στο δομημένο προγραμματισμο μπορούμε να θεωρήσουμε την ύπαρξη ενός συμβολισμού του τύπου parbegin...parend οπου οι εντολες μέσα στο μπλοκ εκτελούνται ταυτόχρονα.</li>
            <li>Επισης μπορούμε να θεωρήσουμε την υποστήριξη δύο ενσωματωμένων συναρτήσεων enter_critical(R) και exit_critical(R) για τον προσδιορισμο κρισιμων τμημάτων αναφορικά με κάποιο πορο R.</li>
        </ul>
        </p>
        <p>
        <h2>Σημαδοφορος</h2>
        <ul>
            <li>Η βασική αρχή στηρίζεται στη χρήση σηματων (signals): δύο ή περισσότερες διεργασίες μπορούν να συγχρονίσουν την εκτέλεση τους μέσω της αποστολής και αναμονής λήψης σηματων.</li>
            <li>Για την αποστολή και καταμετρηση των σηματων χρησιμοποιούνται ειδικές μεταβλητές που λεγονται σημαδοφόροι (semaphores) σε συνδυασμο με δυο θεμελιωδεις λειτουργιες: semWait και semSignal.</li>
            <li>Οι σημαφοροι προταθηκαν απο τον Dijkstra το 1965.</li>
        </ul>
        </p>
        <p>
        <h2>Πράξεις με σημαφορους</h2>
        Μόνο 3 πράξεις μπορούν να γίνουν με ένα σημαφορο:
        <ul>
            <li>Αρχικοποιηση με μια θετική ακεραια τιμή.</li>
            <li>Μείωση της τιμής του σηματοφόρου κατά μία μοναδα με χρήση της εντολής semWait. Αν η τιμή του σηματοφόρου γίνει αρνητική, η διεργασία που εκτέλεσε την εντολή αναστέλλει την εκτελεση της και μπαινει σε ουρα υπο αναστολη διεργασιών σχετιζόμενη με το σηματοφόρο. Διαφορετικά, η διεργασία συνεχίζει την εκτελεση της.</li>
            <li>Αυξηση της τιμής του σημαφορου κατα μια μοναδα με χρήση της εντολής semSignal. An η τιμή του σημαφορου δεν είναι θετική, τότε μια απο τις διεργασιες που βρίσκονται  υπο αναστολη στην ουρα του σημαφόρου (αν υπαρχουν τετοιες διεργασιες) αλλάζει την καταστασή της σε έτοιμη για εκτελεση.</li>
            <li>Εξυπακούεται οτι η εκτελεση των εντολων semWait και semSignal θα πρεπει να γινεται ως ατομική ενεργεια (atomic action).</li>
        </ul>
        </p>
        <p>
        <h2>Δυαδικος σημαφορος</h2>
        <ul>
            <li>Οι δυαδικοι σημαφόροι (binary semaphores) μπορουν να παρουν μονο τις τιμες 0 και 1, ειναι πιο ευκολο να υλοποιηθουν απο τους γενικους σημαφορους και μπορει να αποδειχθει οτι εχουν την ιδια εκφραστική ικανοτητα με τους γενικους σημαφορους.</li>
            <li>Μια παρομοια εννοια ειναι αυτη του μηχανισμου mutex. Η βασικη διαφορα απο τον δυαδικο σημαφορο είναι οτι η διεργασια που κλειδωνει το mutex (θετει την τιμη σε 0) ειναι η μονη που μπορει να το ξεκλειδωσει (να θεσει την τιμή του σε 1). Στους δυαδικους σημαφορους δεν ισχυει αυτος ο περιορισμος και η διεργασια που ξεκλειδωνει ενα δυαδικο σημαφορο δεν ειναι κατ'αναγκη η ιδια που τον κλειδωσε.</li>
        </ul>
        </p>
        <p>
        <h2>ισχυρος/αδυνατος σημαφορος</h2>
        <ul>
            <li>Αν ο ορισμός του σημαφόρου καθορίζει ότι η διεργασία που θα ενεργοποιηθεί είναι η πρώτη στην ουρά (δηλαδή αυτή που βρίστεται υπό αναστολή το μεγαλύτερο χρονικό διάστημα), τότε ο σημαφόρος αυτός λέγεται ισχυρός (strong semaphore).</li>
            <li>Στην αντίθετη περίπτωση που δεν καθορίζεται η σειρά ενεργοποίησης των διεργασιών, ο σημαφόρος αυτός λέγεται αδύνατος (weak semaphore).</li>
        </ul>
        </p>
        <p>
        <h2>Πλεονεκτήματα των σημαφόρων έναντι προηγούμενων τεχνικών</h2>
        <ul>
            <li>Ελαχιστοποίηση του κόστους που συνεπάγεται η ενεργός αναμονή· οι διεργασίες που δεν μπορούν να εισέλθουν στο κρίσιμο τμήμα τίθενται υπό αναστολή και δεν σπαταλούν πόρους του συστήματος.</li>
            <li>Η απρόσμενη διακοπή μίας διεργασίας λόγου κάποιου λάθους, ακόμα και αν γίνει μέσα στο κρίσιμο τμήμα, συνήθως δεν έχει καταστροφικά αποτελέσματα. Το ΛΣ, μέσω εξέτασης των δομών των σημαφόρων που εμπλέκονται σε ένα σενάριο ταυτοχρονισμού, έχει συνολική εικόνα της κατάστασης και μπορεί να αντιδράσει (είτε τερματίζοντας όλες τιες διεργασίες που εμπλέκονται στο σενάριο, είτε επιτρέποντας σε κάποιες από αυτές να συνεχίσουν την εκτέλεση τους).</li>
            <li>Οι τεχνικές υλοποίησης του αμοιβαίου αποκλεισμού είναι εύκολα επεκτάσιμες σε σενάρια που εμπλέκουν πολλαπλές διεργασίες.</li>
            <li>Ο κώδικας συνολικά είναι πιο απλός και κατανοητός.</li>
        </ul>
        </p>
        <p>
        <h2>Το πρόβλημα των αναγνωστών - Εγγραφέων</h2>
        <ul>
            <li>Το πρόβλημα των αναγνωστών - εγγραφέων (readerswriters) μοντελοποιεί την πρόσβαση σε μία βάση δεδομένων.</li>
            <li>Υπάρχει μία ομάδα από διεργασίες που προσπαθούν να διαβάσουν ταυτόχρονα μία περιοχή μνήμης και μία ομάδα από διεργασίες που προσπαθούν να γράψουν ταυτόχρονα στην περιοχή αυτή.</li>
            <li>Μονο μία διεργασία μπορεί ανα πάσα στιγμή να γράφει αλλά πολλές να διαβάζουν.</li>
            <li>Την ώρα που μία διεργασία γράφει καμία αλλη δεν μπορεί να διαβάζει.</li>
        </ul>
        </p>
        <p>
        <h2>Επεξήγηση και μειονεκτήματα της λύσης</h2>
        <ul>
            <li>Γίνεται χρήση δύο σημαφόρων:
                <ul>
                    <li>Ο wsem προστατεύει την κοινή περιοχή για γράψιμο ή διάβασμα.</li>
                    <li>Ο x προστατεύει την πρόσβαση στην κοινή μεταβλήτη readcount.</li>
                </ul>
            </li>
            <li>Η λύση αυτή δινει προτεραιότητα στους αναγνώστες με την έννοια ότι αν έχει εισέλθει στην κοινή περιοχή ένας αναγνώστης, τότε όσο θα έρχονται αναγνώστες δεν θα είναι δυνατόν σε εγγραφείς να χρησιμοποιήσουν την περιοχή.</li>
            <li>Ο λόγος που αυτό ειναι μειονέκτημα είναι γιατί συνήθως σε τέτοια σενάρια έχουμε λίγους εγγραφείς και πολλούς αναγνώστες.</li>
            <li>Επομένως, η λύση αυτή είναι δυνατόν να δημιουργήσει παρατεταμένη στέρηση στους εγγραφείς.</li>
        </ul>
        </p>
        <p>
        <h2>Το πρόβλημα του παραγωγού-καταναλωτή</h2>
        <ul>
            <li>Το πρόβλημα του παραγωγού - καταναλωτή (producer-consumer) είναι ένα από τα κλασσικότερα προβλήματα ταυτοχρονισμού.</li>
            <li>Ένας ή περισσότεροι παραγωγοί παράγουν δεδομένα και τα αποθηκεύουν σε μία προσωρινή μνήμη (buffer).</li>
            <li>Ένας καταναλωτής αφαιρεί τα δεδομένα από τη μνήμη, ένα κάθε φορά.</li>
            <li>Μόνο ένας παραγωγός ή καταναλωτής μπορεί να έχει πρόσβαση στη μνήμη ανά πάσα στιγμή.</li>
            <li>Το πρόβλημα εδώ είναι να αποφευχθούν οι περιπτώσεις να προσπαθήσει ένας παραγωγός να αποθηκεύσει δεδομένα στη μνήμη όταν αυτή είναι γεμάτη ή να προσπαθήσει ο καταναλωτής να αφαιρέσει δεδομένα αν η μνήμη είναι άδεια.</li>
        </ul>
        </p>
        <p>
        <h2>επεξήγηση της λύσης</h2>
        <ul>
            <li>Η ιδεά της λύσης είναι η χρήση της μεταβλητής n (=in-out) για την υλοποίηση των δύο δεικτών in και out.</li>
            <li>Επίσης, ο σημαφόρος <b>s</b> επιβάλει τον αμοιβαίο αποκλεισμό και ο σημαφόρος <b>delay</b> αναγκάζει τον καταναλωτή να περιμένει αν η μνήμη είναι άδεια.</li>
        </ul>
        </p>
        </article>
	<footer>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_06.html">  Επόμενο κεφάλαιο</a>
	</nav>

	</footer
    </body>
</html>

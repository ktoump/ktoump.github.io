<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>Κεφαλαιο 8</title>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_09.html">  Επόμενο κεφάλαιο</a>
	</nav>
	<link rel="stylesheet" type="text/css" href="style.css"/>
    </head>
    <body>
        <article>
            <p>
            <h2>Βασικα χαρακτηριστικα αποθηκευσης διεργασιων στη μνήμη</h2>
            Οι τεχνικές σελιδοποιησης και κατατμησης που εξεταστηκαν εχουν δυο βασικα χαρακτηριστικα:
            <ul>
                <li>Οι αναφορες σε διευθυνσεις μνημης ειναι λογικες και αποκωδικοποιουνται δυναμικα για να δωσουν τις αντιστοιχες απολυτες (φυσικες) τιμες τους.</li>
                <li>Μια διεργασια μπορει να απομακρυνθει απο τη μνημη και κατοπιν να επανελθει σε αυτην και οχι κατ'αναγκη στον ιδιο χωρο που χρησιμοποιησε στο παρελθον.</li>
                <li>Τα μερη απο τα οποια αποτελειται ενα προγραμμα (ειτε ειναι σελιδες ειτε ειναι τμηματα) δεν χρειαζεται να βρισκονται στη μνήμη σε συνοχομενες θεσεις. Αυτο επιτυγχανεται με χρηση τεχνικων μετατοπισης.</li>
            </ul>
            </p>
            <p>
            <h2>αμεσο επακολουθο των προηγουμενων χαρακτηριστικων</h2>
            <ul>
                <li>Αν ισχυουν τα ανωτερω χαρακτηριστικα, τοτε δεν ειναι απαραιτητο ολες οι σελιδες ή τμηματα μιας διεργασιας να βρισκονται στη μνημη την ιδια στιγμή.</li>
                <li>Αν η επομενη εντολη και τα δεδομενα που εμπλεκονται στην εκτελεση της βρισκονται σε καποια σελιδα ή πλαισιο που ειναι ήδη στη μνήμη, η εκτέλεση της διεργασιας μπορει να συνεχισει τουλαχιστον για καποιο χρονικο διαστημα.</li>
                <li>Η παρατηρηση αυτη εγινε απο τον Fotheringham το 1961 και αποτελει τη βαση της αναπτυξης της τεχνικης ιδεατης μνημης.</li>
            </ul>
            </p>
            <p>
            <h2>στρατηγικη εκτελεσης μιας διεργασιας</h2>
            <ul>
                <li>Αν πρεπει να φορτωθει στη μνημη μια νεα διεργασια, το ΛΣ μεταφερει σε αυτην μονο ενα μερος της - το οποιο ειναι το υπαρχον στη μνήμη μερος (resident set)</li>
                <li>Οσο οι αναφορες σε λογικες διευθυνσεις βρισκονται στο υπαρχον στη μνημη μερος της διεργασιας (κατι το οποιο μπορει να ελεγξει το ΛΣ απο τις πληροφοριες που βρισκονται στους πινακες σελιδων η τμηματων), η εκτελεση γινεται κανονικα.</li>
                <li>Αν πρεπει να γινει αναφορα σε λογικη διευθυνση η οποια δεν ανηκει στο υπαρχον στη μνήμη μερος της διεργασιας, τοτε δημιουργειται ενα λαθος προσβασης μνήμης και η διεργασια τιθεται υπο αναστολη.</li>
                <li>Το λαθος προσβασης μνημης μπορει να ειναι σφαλμα σελιδας (page fault) ή σφαλμα τμηματος (segment fault), αναλογα με το αν χρησιμοποιειται σελιδοποιηση η κατατμηση.</li>
                <li>Το ΛΣ πρεπει τωρα να μεταφερει στη μνήμη το μερος εκεινο της διεργασιας στο οποιο ανηκει η λογικη διευθυνση η οποια δημιουργησε το λαθος προσβασης μνήμης.</li>
                <li>Αυτο επιτυγχανεται με μια εντολή Ε/Ε στο δισκο.</li>
                <li>Οσο διαρκει η ενεργεια αυτη, το ΛΣ επιλεγει μια αλλη διεργασια για να εκτελεσθει.</li>
                <li>Οταν το μερος της αρχικης διεργασιας που βρισκοταν στον δισκο φορτωθει στη μνημη, η διεργασια αυτη επανερχεται σε κατασταση ετοιμη για εκτελεση.</li>
            </ul>
            </p>
            <p>
            <h2>επιπτωσεις αυτης της στρατηγικης</h2>
            <ul>
                <li>Περισσότερες διεργασιες μπορουν να βρισκονται στην κυρια μνήμη.
                <ul>
                    <li>Μονο ενα μερος της καθε διεργασιας χρειαζεται να βρισκεται στη μνημη.</li>
                    <li>Περισσοτερες πιθανοτητες να υπαρχει παντα καποια διεργασια ετοιμη για εκτελεση και επομενως να γινεται πιο αποδοτικη χρηση της ΚΜΕ.</li>
                </ul>
                <li>Το μέγεθος σε μνήμη μιας διεργασιας μπορει να ειναι μεγαλυτερο απο τη διαθεσιμη κυρια μνήμη.
                <ul>
                    <li>Λαμβανοντας υπ'οψη οτι η περιφερειακη μνήμη ειναι πολυ μεγαλη, δεν υπαρχει ουσιαστικα κανενας περιορισμος για το μεγεθος μιας διεργασιας.</li>
                </ul></li>
                </li>
            </ul>
            </p>
            <p>
            <h2>πραγματικη και ιδεατη μνήμη</h2>
            <ul>
                <li><b>Πραγματική μνήμη: </b>Η κυρια μνήμη.</li>
                <li><b>Ιδεατη μνήμη: </b>Η περιφερειακη μνήμη του δισκου.</li>
            </ul>
            </p>
            <p>
            <h2>ατερμονη προσκομιση πληροφοριων στη μνήμη</h2>
            <ul>
                <li>Στη συνηθη περιπτωση, σχεδον ολη η κυρια μνήμη θα ειναι καταλυμενη απο διεργασιες.</li>
                <li>Επομενως, οταν πρεπει να προσκομισθει στη μνήμη ενας μερος μιας διεργασιας, καποιο αλλο μερος πρεπει να απομακρυνθει απο εκει.</li>
                <li>Αν το μερος που επιλεχθει να απομακρυνθει ζητηθει αμεσως μετα την απομακρυνση του και αυτο το φαινομενο συνεχισθει για καποιο χρονικο διαστημα, τοτε το συστημα θα σπαταλαει τον περισσοτερο απο το χρονο του στο να μεταφερει πληροφοριες απο και προς την κυρια μνήμη αντι να εκτελει εντολες <b>(thrashing)</b></li>
                <li>Η αποφυγη αυτου του φαινομενου ηταν σημαντικο ερευνητικο προβλημα τη δεκαετια του '70 και οδήγησε στο σχεδιασμο αριθμου αλγοριθμων που βασιζονται στη προσπαθεια προγνωσης για τις πιθανοτητες ενος μερους διεργασιας να χρειασθει στο αμεσο μελλον αναλυοντας το ιστορικο της διεργασιας.</li>
            </ul>
            </p>
            <p>
            <h2>τοπικοτητα των αναφορων</h2>
            <ul>
                <li>Η αρχη της τοπικοτητας των αναφορων (principle of locality) οριζει οτι ανα πασα χρονικη στιγμή η ροη εκτελεσης ενος προγραμματος εστιαζεται μονο σε ενα μερος του κωδικα και των δεδομενων του προγραμματος.</li>
                <li>Κατ'επεκταση, μονο το μερος της διεργασιας στο οποιο βρισκονται η ομαδα των τρεχουσων εκτελουμενων εντολων και τα σχετιζομενα με αυτες δεδομενα χρειαζεται να βρισκεται στη μνήμη για το αμεσο μελλον.</li>
                <li>Επιπλεον, ειναι δυνατον να κανουμε ευφυεις προβλεψεις για τα μερη μιας διεργασιας που θα χρειασθουν στο αμεσο μελλον, ωστε να μην τα απομακρυνουμε απο τη μνήμη και να αποφυγουμε το φαινομενο του thrashing.</li>
                <li>Η τοπικοτητα των αναφορων ειναι αμεση θετικη επιπτωση της χρησης αρθρωτων και δομημενων τεχνικων προγραμματισμου.</li>
            </ul>
            </p>
            <p>
            <h2>Εικονική αναπαράσταση της τοπικοτητας των αναφορών XXX ΕΔΩ ΠΡΕΠΕΙ ΝΑ ΕΧΕΙ ΕΝΑ ΣΧΗΜΑ</h2>
            Παρατηρήστε οτι κατα τη διαρκεια εκτελεσης της διεργασιας, αναφορα σε διευθυνσεις εστιαζεται σε υποσυνολο των σελιδων.
            </p>
            <p>
            <h2>Υλοποιηση της ιδεατης μνήμης</h2>
            Για την αποτελεσματική υλοποιηση της τεχνικής της ιδεατης μνήμης, απαιτουνται δυο προυποθεσεις:
            <ul>
                <li>Το υλικο του συστήματος πρεπει να υποστηριζει σελιδοποιηση ή/και κατάτμηση.</li>
                <li>Το ΛΣ πρεπει να υποστηριζει μηχανισμους μεταφορας σελιδων ή/και τμηματων μεταξύ κυριας και περιφερειακης μνήμης.</li>
            </ul>
            </p>
            <p>
            <h2>ενδιαμεση μνήμη μεταφρασης</h2>
            <ul>
                <li>Για την απεικονιση μιας ιδεατης διευθυνσης στην αντιστοιχη της φυσικη διευθυνση, απαιτουνται δυο προσβασεις στη μνήμη:
                <ul>
                    <li>Μια για το διαβασμα της αντιστοιχης εγγραφης στο πινακα σελιδων.</li>
                    <li>Μια για την προσαγωγή των σχετικων δεδομενων.</li>
                </ul></li>
                <li>Για την επιταχυνση της διαδικασιας αυτης χρησιμοποιειται ενα ειδος πολυ γρηγορης μνήμης που λεγεται ενδιαμεση μνήμη μεταφρασης (translation lookaside buffer).</li>
                <li>Περιεχει τις εγγραφες του πινακα σελιδων για τις σελιδες εκεινες που χρησιμοποιηθηκαν πιο προσφατα.</li>
            </ul>
            </p>
            <p>
            <h2>μεγεθος γρηγορης μνήμης και πολιτικη αντικαταστασης σε αυτην</h2>
            <ul>
                <li>Με την αυξυση του μεγεθους της κυριας μνήμης, μειωνεται η τοπικοτητα των αναφορων.</li>
                <li>Ομως αυξανεται επισης το μεγεθος της πολυ γρηγορης (κρυφης) μνήμης (cache)</li>
                <li>Η εξυπνη τοποθετηση και αντικατασταση σελιδων στη μνήμη cache μπορει να εχει σημαντικο θετικο αντικτυπο στην αποδοση του συστήματος (μειωση μεχρι και 20% της αποτυχιας ευρεσης μιας σελιδας στη μνήμη cache)</li>
            </ul>
            </p>
            <p>
            <h2>πολιτικες αντικαταστασης σελιδων</h2>
            <ul>
                <li>Σκοπος τους ειναι να επιλεξουν την "πιο καταλληλη" σελιδα που πρεπει να απομακρυνθει απο την κυρια μνήμη για να δημιουργηθει χωρος για να φορτωθει καποια αλλη σελιδα απο την περιφερειακή μνήμη.</li>
                <li>Ο ορισμος της "πιο καταλληλης" σελιδας δινεται απο την αρχη της βελτιοστοποιησης (principle of optimality): η σελιδα που πρεπει να αντικατασταθει ειναι αυτη που δεν θα χρειασθει στο μελλον για το μεγαλυτερο χρονικο διαστημα.</li>
                <li>Φυσικα, μια και δεν μπορει να προβλεφθει το μελλον, οι αλγοριθμοι οπυ ακολουθουν προσπαθουν να εκτιμησουν κατα προσεγγιση ποια ειναι η καλυτερη σελιδα, λαμβανοντας υπ'οψη τους το ιστορικο της συμπεριφορας των σελιδων μιας διεργασιας.</li>
                <li>Σημειοτεον οτι οσο πιο πολυπλοκος ειναι ενας αλγοριθμος τοσο περισσοτερο κοστος εχει η υλοποιηση του.</li>
            </ul>
            </p>
            <p>
            <h2>κλειδωμα πλαισιων σελιδων</h2>
            <ul>
                <li>Ανεξαρτητα απο το ποιος αλγοριθμος αντικαταστασης σελιδων εφαρμοζεται, ορισμενα πλαισια σελιδων στη μνημη μπορει να ειναι κλειδωμενα.</li>
                <li>Οι σελιδες που βρισκονται στα κλειδωμενα πλαισια δεν μπορουν να αντικατασταθουν.</li>
                <li>Τα κλειδωμενα πλαισια εχουν πληροφοριες που τις χρειαζεται το ΛΣ για να λειτουργει, οπως:
                <ul>
                    <li>Κωδικας του πυρηνα του ΛΣ</li>
                    <li>Σημαντικες δομες ελεγχου</li>
                    <li>Προσωρινη μνημη.</li>
                </ul>
                </li>
                <li>Το κλειδωμα επιτυγχανεται με την υπαρξη ενος bit κλειδωματος στον πινακα τμηματων η/και σελιδων το οποιο εξεταζει ο αλγοριθμος αντικαταστασης πριν επιλεξει μια σελιδα για να την αποκρυνει απο την κυρια μνήμη.</li>
            </ul>
            </p>
            <p>
            <h2>βασικοι αλγοριθμοι αντικαταστασης σελιδων</h2>
            <ul>
                <li>Βέλτιστος (optimal).</li>
                <li>Λιγοτερο προσφατα χρησιμοποιουμενη σελιδα (least recently used, LRU).</li>
                <li>Πρωτη εισερχομενη, πρωτη εξερχομενη (first in first out, FIFO)</li>
            </ul>
            <h2>βελτιστος</h2>
            <ul>
                <li>Εξεταζει τις εντολες του εκτελουμενου προγραμματος και επιλεγει τη σελιδα εκεινη στην οποια θεωρει οτι θα γινει αναφορα οσο γινεται πιο μακρια στο μελλον.</li>
                <li>Εχει παντα τα καλυτερα αποτελεσματα</li>
                <li>Το προβλημα ειναι οτι δεν μπορουμε να ξερουμε τη μελλοντική συμπεριφορα του προγραμματος.</li>
                <li>Επομενως ο αλγοριθμος δεν μπορει να υλοποιηθει</li>
                <li>Ομως, οπως και ο προηγουμενος, μπορει να χρησιμευσει σαν μεσο συγκρισης για τους υπολοιπους</li>
            </ul>
            <h2>λιγοτερο προσφατα χρησιμοποιουμενη σελιδα</h2>
            <ul>
                <li>Επιλεγει τη σελιδα εκεινη στην οποια δεν εχει γινει αναφορα για το μεγαλυτερο χρονικο διαστημα.</li>
                <li>Με βαση το φαινομενο της τοπικοτητας των αναφορων, οι πιθανοτητες η σελιδα αυτη να χρειασθει στο εγγυς μελλον ειναι μικρες.</li>
                <li>Ο αλγοριθμος αυτος εχει καλες επιδοσεις οι οποιες πλησιαζουν αυτες του βελτιστου.</li>
                <li>Ομως ειναι πολυεξοδος στην υλοποιηση γιατι χρειαζεται να καταγραφεται ο χρονος που εγινε αναφορα σε μια σελιδα καθε φορα που χρησιμοποιειται για αναγνωση η/και τροποποιηση, κατι που εχει μεγαλο κοστος.</li>
            </ul>
            <h2>πρωτη εισερχομενη, πρωτη εξερχομενη</h2>
            <ul>
                <li>Επιλεγει για αντικατασταση τη σελιδα εκεινη που εχει μεινει για μεγαλυτερο χρονικο διαστημα στην κυρια μνημη.</li>
                <li>Βασιζεται στη λογικη οτι οι πιθανοτητες η σελιδα αυτη να συνεχισει να ειναι χρησιμη ειναι μικρες.</li>
                <li>Ειναι απλος στην υλοποιηση (χρειαζεται μονο μια κυκλικη ουρα) αλλα η λογικη στην οποια βασιζεται δεν ειναι συχνα σωστη και ετσι εχει κακη αποδοση.</li>
                <li>Ο λογος που η λογικη δεν ειναι παντα σωστη εγκειται στο γεγονος οτι σε ενα προγραμμα υπαρχουν συχνα περιοχες κωδικα ή/και δεδομένων που χρησιμοποιουνται κατ'εξακολουθηση.<br />
                Σε αυτες τις περιπτωσεις, οι σελιδες που αντιστοιχουν σε αυτες τις περιοχες θα μπαινοβγαινουν συνεχεια στη μνήμη.</li>
            </ul>
            </p>
            <p>
            <h2>χρηση προσωρινης μνημης για σελιδες</h2>
            <ul>
                <li>Μια ενδιαφερουσα παραλλαγη του αλγοριθμου FIFO με χρηση προσωρινης μνημης εφαρμοστηκε στο ΛΣ VAX VMS.</li>
                <li>Οταν ο αλγοριθμος επιλεγει μια σελιδα για αντικατασταση, αυτη δεν μεταφερεται στο δισκο αλλα τοποθετειται σε εναν απο δυο προσωρινους χωρους μνημης (buffers), αναλογα με το αν εχουν τροποποιηθει τα περιεχομενα της η οχι (αυτο επιτυγχανεται οχι με φυσικη μετατοπιση των σελιδων στη μνήμη αλλα με αλλαγη των σχετικων δεικτων στους πινακες σελιδων).</li>
                <li>Αν οι προσωρινοι χωροι ειναι πληρεις, τοτε περιοδικα καποιες απο τις σελιδες αυτες (ξεκινωντας απο αυτες που βρισκονται στους χωρους αυτους για το μεγαλυτερο χρονικο διαστημα) απομακρυνονται απο αυτους.</li>
                <li>Τα πλεονεκτηματα της μεθοδου ειναι οτι για τις μη τροποποιημενες σελιδες αν χρειασθουν ξανα στο διαστημα που αυτες βρισκονται στο προσωρινο χωρο δεν χρειαζεται να μεταφερθουν απο το δισκο και για τις τροποποιημενες σελιδες η μεταφορα τους στο δισκο γινεται σε ομαδες και οχι μια-μια, μειωνοντας ετσι τις πραξεις Ε/Ε.</li> <!-- βρισκονται στην κυρια μνημη? XXX -->
                <li>Το ΛΣ πρεπει να αποφασισει ποσες σελιδες απο καθε διεργασια θα φορτωσει στην κυρια μνήμη.
                <ul>
                    <li>Οσο μικροτερος ειναι ο αριθμος τοσο περισσοτερες διεργασιες θα μπορουν να βρισκονται στη μνήμη.</li>
                    <li>Ομως, οσο μικροτερος ειναι ο αριθμος τοσο μεγαλυτερη θα ειναι και η συχνοτητα σε σφαλματα σελιδων.</li>
                    <li>Επισης, απο ενα σημειο και μετα, παρεχοντας περισσοτερες σελιδες σε μια διεργασια δεν θα επηρεασει σημαντικα τη σηχνοτητα δημιουργιας λαθων σελιδας για αυτη τη διεργασια.</li>
                </ul></li>
            </ul>
            </p>
            <p>
            <h2>Προσεγγισεις στον αριθμο των πλαισιων που κατανεμονται στις διεργασιες</h2>
            <ul>
                <li>Σταθερη κατανομη (fixed allocation)
                <ul>
                    <li>Διατηρει σταθερο τον αριθμο των πλαισιων που χορηγουνται σε μια διεργασια</li>
                    <li>Ο αριθμος αυτος υπολογιζεται απο το ΛΣ οταν δημιουργειται η διεργασια και βασιζεται στις ιδιοτητες της διεργασιας η σε πληροφοριες απο τον προγραμματιστη.</li>
                    <li>Οταν δημιουργειται σφαλμα σελιδας, αντικαθισταται μια απο τις σελιδες αυτων των πλαισιων.</li>
                </ul>
                </li>
                <li>Μεταβλητη κατανομη (variable allocation)
                <ul>
                    <li>Επιτρεπει δυναμικα την αυξηση του αριθμου των πλαισιων καποιας διεργασιας, κυριως αυτων που δημιουργουν πολλα σφαλματα σελιδας, αλλα και τη μειωση των αριθμων τως πλαισιων για διεργασιες που εχουν περιορισμενη αναγκη σε μνημη.</li>
                </ul></li>
            </ul>
            </p>
            <p>
            <h2>Ευρος εφαρμογης των πολιτικων αντικαταστασης σελιδων</h2>
            <ul>
                <li>Οι πολιτικες αντικαταστασης σελιδων μπορει να εφαρμοσθουν σε:
                <ul>
                    <li>Τοπικο επιπεδο (local replacement policy) οπου εξεταζονται μονο οι σελιδες της διεργασιας που δημιουργησε το σφαλμα σελιδας</li>
                    <li>Ολικο επιπεδο (global replacement policy) οπου εξεταζονται ολες οι σελιδες που βρισκονται στην κυρια μνήμη, ανεξαρτητως του αν ανηκουν η οχι στη διεργασια που δημιουργησε το σφαλμα σελιδας.</li>
                </ul>
                </li>
                <li>Ο συνδυασμος της σταθερης ή δυναμικης κατανομης και του τοπικου η ολικου ευρους οδηγει σε τρεις πιθανους συνδυασμους.</li>
            </ul>
            </p>
            <p>
            <h2>Σταθερη κατανομη με τοπικη αντικατασταση</h2>
            <ul>
                <li>Αποφασιζεται απο την αρχη ποσα πλαισια θα χορηγηθουν σε καθε διεργασια, με βαση τις ιδιοτητες της διεργασιας και τις αναγκες του προγραμματος.</li>
                <li>Αν συμβει σφαλμα σελιδας, η αντικατασταση γινεται μονο αναμεσα στις σελιδες της διεργασιας που βρισκονται στη μνήμη.</li>
                <li>Αν η κατανομη δεν επαρκει, τοτε θα δημιουργηθουν πολλα σφαλματα σελιδων.</li>
                <li>Αν η κατανομη ειναι υπερ το δεον, τοτε θα εχουμε μειωμενο αριθμο διεργασιων στη μνημη και κατ' επεκταση ειτε υποχρησιμοποιηση της ΚΜΕ ή επιπλεον κοστος σε εναλλαγη διεργασιων.</li>
            </ul>
            </p>
            <p>
            <h2>Μεταβλητη κατανομη με ολικη αντικατασταση</h2>
            <ul>
                <li>Η πιο ευκολη στην υλοποιηση προσεγγιση (και γι'αυτο χρησιμοποιειται σε πολλα ΛΣ)</li>
                <li>Το ΛΣ διαρηρει μια λιστα απο ελευθερα πλαισια</li>
                <li>Οταν μια διεργασια προκαλεσει σφαλμα σελιδας, το ΛΣ της παραχωρει ενα πλαισιο απο αυτην τη λιστα και κατ' επεκταση επεκτεινεται το μεγεθος της διεργασιας στη μνημη με επακολουθο τη σταδιακη μειωση των σφαλματων σελιδας για αυτη τη διεργασια.</li>
                <li>Οταν δεν υπαρχουν ελευθερα πλαισια, το ΛΣ πρεπει να αφαιρεσει ενα απο αυτα που διαθετει καποια διεργασια και να το παραχωρησει σε αυτην που δημιουργησε το σφαλμα σελιδας.
                <br /><i>Εδώ βρισκεται το μειονεκτημα της μεθοδου αυτης: να αποφασισθει σε ποια διεργασια θα υπαρξει η μικροτερη αρνητικη επιπτωση αν της αφαιρεθει ενα πλαισιο απο αυτα που διαθετει</i></li>
            </ul>
            </p>
        </article>
	<footer>
	<nav>
	<a href="index.html">Περιεχόμενα </a>
	<br/>
	<a href="ch_09.html">  Επόμενο κεφάλαιο</a>
	</nav>
	</footer>
    </body>
</html>
